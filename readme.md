# Установка
* composer install
* Создать .env из .env.example
* php artisan key:generate
* php artisan migrate
* php artisan db:seed
* php artisan queue:work

# Логика
Middleware **RegisterVisit** ставит в очередь **HandleVisitJob**,
которая регистрирует факт посещения. Это сделано для того,
чтобы уменьшить время возврата ответа от сервера.
Работа с Redis происходит через интерфейс **VisitRepositoryInterface**,
что позволяет в последствии изменить хранилище, если потребуется.
Структура базы в Redis:

* Посещения: visit:{id посещения}:{uri} => Visit (json)
* Счетчик visit_id: next_visit_id

Так же для удобства я записываю URI страниц в сэт 
"uri_set", чтобы потом получить их список для админки.

# Статистика
Вообще для статистики я бы в фоне реплицировал данные из
Redis в любую RDBMS, но по условиям тестового задания так нельзя.
**StatisticsService** может собирать статистику по любому
из свойств сущности **Visit**. Сначала мы задаем ему массив 
этих параметров (section), затем через **fact(\Closure)** скармливаем
ему данные от команды Redis **SCAN**. Сделано это для того, чтобы на случай,
если нам придется выгрузить несколько миллионов записей, не произошло 
превышения лимита памяти и сервер не повис.

# Админка
* admin@test.com
* 123

Есть роуты 15 страниц (кол-во можно изменить, см. **routes/web.php**),
по ним можно побегать. В админке статистика как по всему сайту, так и по роутам.
